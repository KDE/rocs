<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [

  <!ENTITY kappname "&rocs;">
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Spanish "INCLUDE">

]>
<book id="rocs" lang="&language;">

<bookinfo>
<title
>Manual de &rocs;</title>
<authorgroup>
<author
><personname
> <firstname
>Tomaz</firstname
> <surname
>Canabrava</surname
> </personname
> <email
>tomaz.canabrava@gmail.com</email
> </author>
<author
><personname
> <firstname
>Andreas</firstname
> <surname
>Cord-Landwehr</surname
> </personname
> <email
>cordlandwehr@kde.org</email
> </author>

<othercredit role="translator"
><firstname
>Leticia</firstname
><surname
>Martín Hernández</surname
><affiliation
><address
><email
>leticia.martin@gmail.com</email
></address
></affiliation
><contrib
>Traducción</contrib
></othercredit
> <othercredit role="translator"
><firstname
>Rocío</firstname
><surname
>Gallego</surname
><affiliation
><address
><email
>traducciones@rociogallego.com</email
></address
></affiliation
><contrib
>Traducción</contrib
></othercredit
> 
</authorgroup>

<date
>2016-04-10</date>
<releaseinfo
>Rocs 2.1.50 (Applications 16.04)</releaseinfo>

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>&rocs; is a graph theory tool by &kde;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>kdeedu</keyword>
<keyword
>matemáticas</keyword>
<keyword
>matemáticas</keyword>
<keyword
>grafos</keyword>
<keyword
>nodo</keyword>
<keyword
>arista</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title
>Introducción</title>
<para
>En este capítulo le proporcionamos un resumen de las funcionalidades principales y de los flujos de trabajo típicos. Las partes más importantes son <xref linkend="introduction-nutshell"/> y <xref linkend="scripting"/>, que deberían bastar para que cualquier nuevo usuario comience a usar &rocs;. </para>

<sect1 id="introduction-goals">
<title
>Objetivos, audiencia de destino y flujo de trabajo</title>
<para
>&rocs; es una herramienta de teoría de grafos para todos aquellos interesados en el diseño y el análisis de algoritmos de grafos. Esto incluye:</para>
<itemizedlist>
    <listitem
><para
>a profesores que quieran mostrar algoritmos a sus estudiantes,</para
></listitem>
    <listitem
><para
>a estudiantes e investigadores que quieran ver como funciona un algoritmo,</para
></listitem>
    <listitem
><para
>y a cualquier persona interesada en estructuras de datos y algoritmos.</para
></listitem>
</itemizedlist>
<para
>For all them, &rocs; provides an easy to use graphical editor for creating graphs, a powerful scripting engine to execute algorithms, and several helper tools for simulations, experiments, and graph exports. The typical way of using &rocs; is to create a graph, either by hand (i.e., dragging nodes and edges to the whiteboard), or by using one of the graph generators. Graph algorithms then can be implemented and executed on the created graph and all changes, which the algorithm performs, are visible immediately in the graph editor. </para>

<screenshot>
<screeninfo
>Una captura de pantalla de &rocs;.</screeninfo>
<mediaobject>
<imageobject>
<imagedata fileref="rocs-screenshot.png" format="PNG"/>
</imageobject>
<textobject>
<phrase
>Una captura de pantalla de &rocs;.</phrase>
</textobject>
</mediaobject>
</screenshot>
</sect1>

<sect1 id="introduction-nutshell">
<title
>&rocs; en pocas palabras</title>
<para
>Cada sesión de &rocs; es un proyecto: cuando abra &rocs; se creará un proyecto vacío; cuando cargue algún proyecto, se convertirá en proyecto activo. En sí, un proyecto consta de <emphasis
>documentos de grafos</emphasis
>, de <emphasis
>guiones o algoritmos</emphasis
>. y de un <emphasis
>diario</emphasis
>. </para>

<sect2>
<title
>Documentos de grafos</title>
<para
>Un documento de grafos representa el contenido de una pizarra en el editor de grafos. Contiene información sobre los tipos de nodo y aristas definidos por el usuario y sus propiedades, así como sobre los nodos y aristas ya creados. Es decir, &rocs; entiende el conjunto de todos los nodos y aristas de un documento de grafos (no necesariamente conectados) que componen un grafo. Todo lo que pertenezca a un documento de grafos permanece accesible para el motor de guiones usando el objeto global <userinput
><command
>Document</command
></userinput
>. </para>
</sect2>

<sect2>
<title
>Tipos de aristas</title>
<para
>In some scenarios, graphs consist of different types of edges (e.g., an undirected graph plus the tree edges computed by a breadh-first-search algorithm) that shall be handled and displayed differently. For this, besides a default edge type, you can define arbitrary other edge types. Each edge type has its individual visual representation, dynamic properties, and can be set to be either undirected or directed. The scripting interface provides convenience methods to specifically access only edges of specific types. </para>
</sect2>

<sect2>
<title
>Tipos de nodos</title>
<para
>Analog to edge types, you can define different types of nodes of a graph (e.g., to give some nodes special roles). Each node type has its own visual representation and dynamic properties. </para>
</sect2>

<sect2>
<title
>Propiedades</title>
<para
>Every (node or edge) element can have properties. Those properties must be setup at the corresponding node or edge type. Properties are identified and accessed by their names and can contain any value. To create new or change existing properties, use the <guilabel
>Element Types</guilabel
> sidebar and use the <inlinemediaobject
><imageobject
><imagedata fileref="hi22-action-rocsproperties.png" format="PNG"/> </imageobject
></inlinemediaobject
><guibutton
>Properties</guibutton
> button to open the property dialog. </para>
<para
>You can also use the scripting engine to access registered properties and change their values. In the following example we assume that the property "weight" is registered for the default edge type. <programlisting
>var nodes = Document.nodes()
for (var i = 0; i &lt; nodes.length; ++i){
    nodes[i].weight = i;
}
for (var i = 0; i &lt; nodes.length; ++i){
    Console.log("peso del nodo " + i + ": " + nodes[i].weight);
}
</programlisting>
</para>
</sect2>
</sect1>

<sect1 id="introduction-tutorial">
<title
>Tutorial</title>
<para
>En esta sección queremos crear un proyecto de ejemplo para explorar algunas de las funciones más importantes de &rocs;. El objetivo es crear un grafo y un guion que ilustre un sencillo algoritmo de aproximación a 2 para el problema de la <emphasis
>cobertura de vértices mínima</emphasis
>. En este problema se debe encontrar un subconjunto de nodos del grafo C del mínimo tamaño, de modo que cada arista de grafo esté conectada al menos a un nodo de C. Este problema es NP-complejo y deseamos ilustrar cómo encontrar una aproximación de factor 2 buscando una coincidencia en el grafo propuesto. </para>
<para
>Our goal is to visualize the relationship of the matching and the minimum vertex cover. For this, we want to specify two edge types, one to display matching edges and one type to display "ordinary" edges, as well as two node types that we use to distinguish nodes contained in C and those not contained in C. </para>

<sect2>
<title
>Generación del grafo</title>
<para
>Para crear el grafo, usaremos el generador por omisión que proporciona &rocs;. Está disponible en menú principal: <menuchoice
><guimenu
>Documento de grafo</guimenu
> <guisubmenu
>Herramientas</guisubmenu
> <guimenuitem
>Generar grafo</guimenuitem
></menuchoice
>. Allí seleccionamos un <guilabel
>Grafo aleatorio</guilabel
> con 30 nodos, 90 aristas y semilla 1 (la semilla es la inicial para el generador de grafos aleatorios; si usa la misma semilla varias veces, se volverán a reproducir los mismos grafos). </para>
</sect2>

<sect2>
<title
>Creación de los tipos de elementos</title>
<para
>We use the <guilabel
>Element Types</guilabel
> and create a second node type as well as a second edge type. For both new types we open the properties dialog by using the respective <guibutton
>Properties</guibutton
> buttons and set the IDs to <literal
>2</literal
>. Furthermore, we change the colors of elements of these two new types (to distinguish them from the default types). Finally, we set all edge types to be bidirectional, and the IDs of the default types to <literal
>1</literal
>. </para>
</sect2>

<sect2>
<title
>El algoritmo</title>
<para
>Por último, tenemos que implementar el algoritmo de aproximación. Para ello usaremos la siguiente implementación: </para>
<programlisting
>for (var i=0; i &lt; Document.nodes.length; i++) {
    Document.nodes[i].type = 1;
}
for (var i=0; i &lt; Document.edges.length; i++) {
    Document.edges[i].type = 1;
}

var E = Document.edges(); // conjunto de aristas sin procesar
var C = new Array();      // aristas coincidentes
while (E.length 
> 0) {
    var e = E[0];         // tomamos la primera arista e={u,v}
    var u = e.from();
    var v = e.to();
    e.type = 2;           // indicamos que la arista es coincidente
    E.shift();            // eliminar e (es decir, E[0]) de la lista de aristas
    C.push(u);            // añadir u a C
    C.push(v);            // añadir v a C

    // marcar u,v como nodos en C
    u.type = 2;
    v.type = 2;

    // eliminar de E todas las aristas en común con u o v
    var adjacent = u.edges();
    for (var i=0; i &lt; adjacent.length; i++) {
        var index = E.indexOf(adjacent[i]); // encontrar el índice
        if (index != -1) {
            E.splice(index, 1); // eliminarla si se encuentra
        }
    }
    var adjacent = v.edges();
    for (var i=0; i &lt; adjacent.length; i++) {
        var index = E.indexOf(adjacent[i]); // encontrar el índice
        if (index != -1) {
            E.splice(index, 1); // eliminarla si se encuentra
        }
    }
}
Console.log("La cobertura de vértices contiene " + C.length + " nodos.");
</programlisting>
</sect2>

<sect2>
<title
>Ejecución del algoritmo</title>
<para
>The algorithm can be executed by the <guibutton
>Run</guibutton
> button at the script control panel. </para>
</sect2>
</sect1>
</chapter>

<chapter id="user-interface">
<title
>La interfaz de usuario de &rocs;</title>

<sect1 id="user-interface-all">
<title
>Elementos principales de la interfaz de usuario</title>
<para
>La interfaz de usuario se divide en varias partes lógicas tal como se presentan en la captura de pantalla de más abajo. </para>
<screenshot>
    <screeninfo
>Elementos de la interfaz gráfica de usuario de &rocs;.</screeninfo>
    <mediaobject>
    <imageobject>
    <imagedata fileref="rocs-interfaces.png" format="PNG"/>
    </imageobject>
    <textobject>
    <phrase
>Elementos de la interfaz gráfica de usuario de &rocs;.</phrase>
    </textobject>
    </mediaobject>
</screenshot>
<variablelist>
<varlistentry>
    <term
>Editor de grafos</term>
    <listitem
><para
>The editor provides a whiteboard at that nodes and edges can be placed. Double-clicking at any of its elements opens a corresponding property menu. You can use the tools from the <emphasis
>Graph Editor Toolbar</emphasis
> to create and modify graphs.</para
></listitem>
</varlistentry>
<varlistentry>
    <term
>Graph Editor Toolbar</term>
    <listitem
><para
>The toolbar provides the <inlinemediaobject
><imageobject
><imagedata fileref="hi22-actions-rocsnode.png" format="PNG"/></imageobject
> </inlinemediaobject
><guibutton
>Create Node</guibutton
> or <inlinemediaobject
><imageobject
><imagedata fileref="hi22-actions-rocsedge.png" format="PNG"/></imageobject
></inlinemediaobject
><guibutton
>Create Edge</guibutton
> tools, for creating new elements on the whiteboard. Note the extra-toolbar for selecting the respective node or edge type that becomes visible of one of these tools is selected. Also tools for selecting and moving as well as deleting elements are available here. For details see <xref linkend="user-interface-toolbar"/>. </para
></listitem>
</varlistentry>
<varlistentry>
    <term
>Barra lateral</term>
    <listitem
><para
>A la derecha puede encontrar la barra lateral que le proporciona diversas herramientas para su flujo de trabajo. <itemizedlist>
        <listitem
><para
>Element Types: This widget gives you direct access to the available edge and node types.</para
></listitem>
        <listitem
><para
>Journal: Each project has its own journal that can be used to, &eg; note tasks, results, or observations.</para
></listitem>
        <listitem
><para
>Scripting API: To get direct access to the script documentation, you can open this widget.</para
></listitem>
        </itemizedlist>
    </para
></listitem>
</varlistentry>
<varlistentry>
    <term
>Editor de guiones</term>
    <listitem
><para
>En este editor de texto puede escribir algoritmos como se explica con más detalle en <xref linkend="scripting"/>. Puede trabajar en varios documentos de guiones al mismo tiempo usando varias pestañas. </para
></listitem>
</varlistentry>
<varlistentry>
    <term
>Script Output</term>
    <listitem
><para
>Este área de texto muestra información de depuración o la salida del guion del algoritmo, dependiendo de la preferencia indicada en la parte superior de este elemento gráfico. Si el guion produce un error, se muestra de forma automática la salida de depuración. </para
></listitem>
</varlistentry>
<varlistentry>
    <term
>Controles</term>
    <listitem
><para
>Here you can find the controls for executing scripts. You can execute the script that is currently open at the script editor by pressing <guiicon
>Run</guiicon
>. While the script is executed, it is possible to stop execution by pressing the <guiicon
>Stop</guiicon
> button. </para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="user-interface-toolbar">
<title
>Graph Editor Toolbar</title>
<para
>This toolbar consists of the following actions. Clicking at an action means that your mouse pointer applies this action at the graph editor whiteboard:</para>
<itemizedlist>
<listitem
><para>
<inlinemediaobject
><imageobject>
<imagedata fileref="hi22-actions-rocsselectmove.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Select and Move</guilabel
>: To select elements, either click at unused space at the whiteboard, keep the mouse pressed and draw a rectangle that contains some data elements and/or edges to select these elements or otherwise directly click at an unselected element to select this element. If you click at a selected element or a set of selected elements, respectively, by keeping the mouse pressed and moving around you can move these elements. Moving selected elements is also possible with the arrow keys.</para
></listitem>
<listitem
><para>
<inlinemediaobject
><imageobject>
<imagedata fileref="hi22-actions-rocsnode.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Create Node</guilabel
>: Click at an arbitrary position at the graph editor whiteboard to create a new data element that belongs to the currently selected data structure. By keeping the mouse pointer pressed at the button, a menu shows up at which the data type of the new created data elements can be selected (only if different data types exist).</para
></listitem>
<listitem
><para>
<inlinemediaobject
><imageobject>
<imagedata fileref="hi22-actions-rocsedge.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Create Edge</guilabel
>: Click at one data element, keep the mouse pressed and draw a line to another data element to which the edge shall point. This action is only successful if the current graph allows to add this edge (&eg;, in an undirected graph you are not allowed to add multiple edges between two data elements). By keeping the mouse pointer pressed at the button, a menu shows up at which the edge type of the new created edges can be selected (only if different edge types exist).</para
></listitem>
<listitem
><para>
<inlinemediaobject
><imageobject>
<imagedata fileref="hi22-actions-rocsdelete.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Delete</guilabel
>: Click at an element to delete it. If you delete a node, all adjacent edges are also deleted.</para
></listitem>
</itemizedlist>
</sect1>

<!--FIXME nop alignment action any more?-->
</chapter>

<chapter id="scripting">
<title
>Guiones</title>
<sect1>
    <title
>Ejecución de algoritmos en &rocs;</title>
<para
>&rocs; internally uses the QtScript Java Script engine. This means, all algorithms that you implement must use Java Script. In the following, we explain how to access and change elements of a graph document from the scripting engine. It is important to note that changes done by the scripting engine are directly reflected at the properties at the graph editor elements. </para>

<sect2>
<title
>Control de la ejecución del guion</title>
<para
>Existen diferentes modos para ejecutar los algoritmos: </para>
<itemizedlist>
    <listitem
><para>
        <inlinemediaobject
><imageobject>
        <imagedata fileref="hi22-actions-controls-run.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Run</guilabel
>: Execute the script until it finishes.</para
></listitem>
    <listitem
><para>
        <inlinemediaobject
><imageobject>
        <imagedata fileref="hi22-actions-control-stop.png" format="PNG"/></imageobject
></inlinemediaobject
> <guilabel
>Stop</guilabel
>: Stop script execution (only available while a script is executed).</para
></listitem>
</itemizedlist>
</sect2>

<sect2>
<title
>Script Output</title>
<para
>Durante la ejecución de un algoritmo, la salida de depuración y del programa se muestran en <emphasis
>Depuración y Salida del guion</emphasis
>. Si el motor de guiones detecta un error de sintaxis en el guion, también se muestra dicho error como un mensaje de depuración. Tenga en cuenta que todos los mensajes del programa también se muestran en la salida de depuración (como texto en negrita). </para>
<para
>Puede controlar el texto que se muestra en la salida del guion mediante las siguientes funciones: </para>
<programlisting
>Console.log(string mensaje);            // muestra el mensaje como salida del guion
    Console.debug(string mensaje);             // muestra el mensaje como salida de depuración
    Console.error(string mensaje);          // muestra el mensaje comosalida de error
</programlisting>
</sect2>

<sect2>
<title
>API del motor de guiones</title>
<para
>Las diferentes partes de &rocs; proporcionan elementos estáticos a los que se puede acceder desde el motor de guiones. Son las siguientes: <itemizedlist
> <listitem
><para
><userinput
><command
>Document</command
></userinput
> para el documento de grafos</para
></listitem
> <listitem
><para
><userinput
><command
>Console</command
></userinput
> para la salida de registro de la consola</para
></listitem
> </itemizedlist
> Para el uso de la API y para una guía sobre los métodos que contienen, consulte la ayuda en línea disponible en la barra lateral de &rocs;. </para>
</sect2>
</sect1>
</chapter>

<chapter id="import-export">
<title
>Importar y exportar</title>
<sect1 id="import-export-projects">
    <title
>Intercambiar proyectos de &rocs;</title>
    <para
>&rocs; projects can be imported and exported as archived <literal
>.tar.gz</literal
> files. These archives can be used to exchange projects. Import and Export can be done with <menuchoice
><guimenu
>Graph Document</guimenu
> <guimenuitem
>Import Graph</guimenuitem
></menuchoice
> and <menuchoice
><guimenu
>Graph Document</guimenu
> <guimenuitem
>Export Graph as</guimenuitem
></menuchoice
>, respectively. </para>

<sect2 id="import-export-graphs">
    <title
>Importar y exportar documentos de grafos</title>
    <para
>En la actualidad, &rocs; permite importar y exportar en los siguientes formatos de archivos:</para>
    <itemizedlist>
        <listitem
><para
>DOT files, also known as Graphviz files</para
></listitem>
        <listitem
><para
>GML files</para
></listitem>
        <listitem
><para
>Archivos en formato de grafos Trivial</para
></listitem>
        <listitem
><para
>El formato del lenguaje de marcas Keyhole</para
></listitem>
    </itemizedlist>

<sect3 id="format-specification-tgf">
<title
>El formato de archivo de grafos Trivial</title>
<para
>The <emphasis
>Trivial Graph Format</emphasis
> (TGF) is a simple text-based file format for describing graphs. A TGF file consists of a list of node definitions, that map the node IDs to labels, followed by a list of the edges. In this format it is only possible to have one label per node and one value per edge. &rocs; interprets imported graphs as undirected graphs. Exported graphs will contain two edges per connection if connections are bidirectional. </para>

<sect4>
<title
>Especificación del formato</title>
    <itemizedlist>
        <listitem
><para
>The file starts with a list of nodes (one node per line), followed by a line with the only character "#", followed by a list of edges (one edge per line).</para
></listitem>
        <listitem
><para
>Un nodo consta de un entero (identificador), seguido por un espacio y por una cadena de texto.</para
></listitem>
        <listitem
><para
>Una arista consta de dos enteros (identificadores) separados por un espacio, seguidos por un espacio y una cadena de texto. Se supone que la arista dirigida apunta desde el primer identificador hasta el segundo.</para
></listitem>
    </itemizedlist>
</sect4>
<sect4>
<title
>Ejemplo</title>
<programlisting
>1 nodo inicial
2 transmisor
3 pila
#
1 2 azul
2 1 rojo
2 3 verde
</programlisting>
</sect4>
</sect3>

<sect3 id="format-specification-dot">
<title
>DOT Language / Graphviz Graph File Format</title>
<para
>The DOT language is a plain text graph description language that allows both,a good human readable representation of graphs as well as an efficient processing by graph layout programs. DOT is the default file format for the Graphviz graph visualization suite, but is also widely used by other graph tools. The usual file extensions for DOT are <emphasis
>.gv</emphasis
> and <emphasis
>.dot</emphasis
>. </para>

<sect4>
<title
>Funcionalidades no permitidas</title>
<para
>&rocs; can parse every graph file that contains a graph specified according to the DOT language specification<footnote
><para
>http://www.graphviz.org/content/dot-language</para
></footnote
>. The support of language features is complete, despite of the following exceptions: </para>
    <itemizedlist>
        <listitem
><para
>subgrafo: debido a la falta del concepto de subgrafo en &rocs;, los subgrafos solo se importan como un conjunto de elementos de datos y conexiones. En especial, no se importan las conexiones hacia o desde subgrafos.</para
></listitem>
        <listitem
><para
>Atributos &HTML; y &XML;: los atributos (como las etiquetas) que contienen sintaxis &HTML; o &XML; se leen sin cambios. En especial, no se lee de estos atributos ninguna información sobre ajustes de tipos de letra ni estilos.</para
></listitem>
    </itemizedlist>
</sect4>
<sect4>
<title
>Ejemplo</title>
<programlisting
>digraph miGrafo {
    a -> b -> c;
    b -> d;
}
</programlisting>
</sect4>
</sect3>
</sect2>
</sect1>
</chapter>

<chapter id="credits">
<title
>Créditos y licencia</title>

<para
>&rocs; </para>
<para
>Copyright del programa:</para>
<itemizedlist>
	<listitem
><para
>Copyright 2008 Ugo Sangiori (ugorox EN gmail.com)</para
></listitem>
	<listitem
><para
>Copyright 2008-2012 Tomaz Canabrava (tcanabrava EN kde.org)</para
></listitem>
	<listitem
><para
>Copyright 2008-2012 Wagner Reck (wagner.reck EN gmail.com)</para
></listitem>
	<listitem
><para
>Copyright 2011-2015 Andreas Cord-Landwehr (cordlandwehr EN kde.org)</para
></listitem>
</itemizedlist>

<para
>Copyright de la documentación:</para>
<itemizedlist>
	<listitem
><para
>Copyright de la documentación 2009 &Anne-Marie.Mahfouf; &Anne-Marie.Mahfouf.mail;</para
></listitem>
	<listitem
><para
>Copyright de la documentación 2009 Tomaz Canabrava (tcanabrava EN kde.org)</para
></listitem>
	<listitem
><para
>Copyright de la documentación 2011-2015 Andreas Cord-Landwehr (cordlandwehr EN kde.org)</para
></listitem>
</itemizedlist>

<para
>Traducido por Leticia Martín Hernández <email
>leticia.martin@gmail.com</email
>, Rocío Gallego<email
>traducciones@rociogallego.com </email
> y Eloy Cuadra <email
>ecuadra@eloihr.net</email
>.</para
> &underFDL; &underGPL; </chapter>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes: nil
sgml-general-insert-case: lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
